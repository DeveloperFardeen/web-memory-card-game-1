<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Match - Dark</title>
  <meta name="description" content="A minimal dark-themed Memory Card Game with three difficulty levels." />
  <style>
    :root{
      --bg: #0d1018;
      --panel: #14192b;
      --panel-2: #11162a;
      --text: #e6e8ef;
      --muted: #aab0c0;
      --accent: #7c9cff;
      --accent-2:#5ef0c3;
      --danger: #ff5e7a;
      --card: #1a2040;
      --card-2:#1e2550;
      --ring: #b6c3ff55;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% -10%, #142044 0%, transparent 60%), radial-gradient(1200px 800px at 120% 10%, #1a254f 0%, transparent 65%), var(--bg);
      color:var(--text);
      display:flex; flex-direction:column;
    }
    header{
      padding:18px 20px;
      background: linear-gradient(180deg, rgba(124,156,255,.08), transparent 60%);
      border-bottom:1px solid #283056;
    }
    header .title{
      font-weight:800; letter-spacing:.5px; font-size:20px;
      display:flex; align-items:center; gap:10px;
    }
    header .title span.logo{
      display:inline-grid; place-items:center;
      width:28px; height:28px; border-radius:8px;
      background:linear-gradient(135deg, var(--accent), #9ac0ff);
      color:#0d1020; font-weight:900; text-shadow:0 1px 0 #ffffff90;
      box-shadow: 0 6px 20px #7c9cff40;
    }
    main{width:min(1100px, 96vw); margin:16px auto; flex:1; display:flex; flex-direction:column; gap:14px}
    .toolbar{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg, #0f1430cc, #0f1430aa);
      border:1px solid #2a3568; border-radius:14px; padding:10px 12px; box-shadow: var(--shadow);
    }
    .group{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    label{font-size:13px; color:var(--muted)}
    select, button{
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      color:var(--text);
      border:1px solid #2a3568;
      border-radius:10px;
      padding:10px 12px;
      font-size:14px; line-height:1;
      box-shadow: inset 0 0 0 1px #00000040, var(--shadow);
    }
    select:focus, button:focus{outline:2px solid var(--ring); outline-offset:2px}
    button.accent{
      background: linear-gradient(180deg, #1b2350, #171e46);
      border-color:#3b4aa1;
      color:#e9edff;
    }
    .stats{
      display:flex; gap:14px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:14px;
    }
    .stats b{color:var(--accent-2)}
    .board{
      --cols: 4;
      display:grid; gap:12px;
      grid-template-columns: repeat(var(--cols), minmax(70px, 1fr));
      background: linear-gradient(180deg, #0d1330, #0d1230);
      padding:16px; border-radius:16px;
      border:1px solid #2a3568; box-shadow: var(--shadow);
      min-height:260px;
    }
    @media (min-width: 860px){
      .board{gap:14px}
    }

    /* Card */
    .card{
      position:relative; perspective:900px;
      border-radius:12px; overflow:visible;
    }
    .card button{
      all:unset;
      cursor:pointer; display:block; width:100%; aspect-ratio: 3 / 4;
      position:relative; border-radius:12px;
      transform-style:preserve-3d;
      transition: transform .5s cubic-bezier(.2,.6,.2,1);
      outline:none;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
    }
    .card button:focus-visible{box-shadow:0 0 0 3px var(--ring)}
    .face{
      position:absolute; inset:0;
      display:grid; place-items:center;
      font-size: clamp(26px, 6vw, 48px);
      border-radius:12px;
      backface-visibility:hidden;
      user-select:none;
    }
    .front{
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border:1px solid #2b356a;
      color:#a9b5ff;
      letter-spacing:2px; font-weight:700;
    }
    .front::after{
      content:"?"; filter: drop-shadow(0 6px 12px #00000040);
    }
    .back{
      background: radial-gradient(120px 80px at 50% 30%, #26317a 0%, transparent 70%), linear-gradient(160deg, #141a3a, #141a3a);
      border:1px solid #35408b;
      transform: rotateY(180deg);
    }
    .flipped{ transform: rotateY(180deg) }
    .matched .back{
      background: linear-gradient(180deg, #152b37, #12262f);
      border-color:#1b8b74;
      color:#c7fff0;
      position:relative;
    }
    .matched .back::after{
      content:""; position:absolute; inset:-6px; border-radius:14px;
      border:2px solid #5ef0c355; box-shadow: 0 0 24px #5ef0c330 inset;
      pointer-events:none;
    }
    .disabled{pointer-events:none; opacity:.75}

    /* Modal */
    .modal{
      position:fixed; inset:0; display:grid; place-items:center; background:rgba(5,8,15,.6);
      opacity:0; visibility:hidden; transition:.25s ease;
      padding:16px;
    }
    .modal.show{opacity:1; visibility:visible}
    .dialog{
      width:min(520px, 96vw);
      background: linear-gradient(180deg, #0f1430, #0e132b);
      border:1px solid #2a3568; border-radius:16px; padding:18px;
      box-shadow: var(--shadow);
      text-align:center;
    }
    .dialog h2{margin:6px 0 10px}
    .dialog p{margin:6px 0; color:var(--muted)}
    .dialog .row{display:flex; gap:10px; justify-content:center; margin-top:12px; flex-wrap:wrap}
    .pill{
      padding:8px 12px; border-radius:999px; border:1px solid #2a3568;
      background: linear-gradient(180deg, #12183a, #121739); color:#cfd6ff; font-size:14px;
    }
    footer{
      color:#7f879d; font-size:12px; text-align:center; padding:10px 0 20px;
    }
    .visually-hidden{
      position:absolute !important; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <span class="logo">MM</span>
      Memory Match
    </div>
  </header>

  <main>
    <div class="toolbar" role="region" aria-label="Game controls">
      <div class="group">
        <label for="level">Difficulty</label>
        <select id="level" aria-label="Select difficulty">
          <option value="easy">Easy — 6 pairs (4 x 3)</option>
          <option value="medium" selected>Medium — 8 pairs (4 x 4)</option>
          <option value="hard">Hard — 12 pairs (6 x 4)</option>
        </select>
        <button id="restart" class="accent" aria-label="Restart game">Restart</button>
      </div>
      <div class="stats" aria-live="polite">
        <span>Moves: <b id="moves">0</b></span>
        <span>Time: <b id="time">00:00</b></span>
        <span>Best: <b id="best">—</b></span>
      </div>
    </div>

    <div id="board" class="board" aria-label="Memory board" aria-live="polite"></div>
  </main>

  <div id="win-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="win-title" aria-describedby="win-desc">
    <div class="dialog">
      <h2 id="win-title">You Win! 🎉</h2>
      <p id="win-desc">Great memory. Here are your results.</p>
      <div class="row">
        <span class="pill">Moves: <b id="sum-moves">0</b></span>
        <span class="pill">Time: <b id="sum-time">00:00</b></span>
        <span class="pill">Best: <b id="sum-best">—</b></span>
      </div>
      <div class="row" style="margin-top:14px">
        <button id="play-again" class="accent">Play again</button>
        <button id="change-level">Change level</button>
      </div>
    </div>
  </div>

  <footer>
    Minimal Memory Card Game • Dark theme • MIT Licensed
  </footer>

  <script>
    ;(function(){
      const EMOJIS = [
        '🐶','🐱','🦊','🐸','🐼','🐵','🦄','🐨','🐯','🐹','🐙','🐞','🦉','🐝','🦋',
        '🍕','🍔','🍣','🍩','🍓','🍎','🍉','🍇','🌮','🥑','🧁','🍪','🌶️',
        '🌈','⭐','⚽','🏀','🎲','🎧','🚀','🛸','🌙','☕','🎹','🎨','📚','💡','🪄','🧠'
      ];
      const LEVELS = {
        easy:   { cols: 4, pairs: 6 },
        medium: { cols: 4, pairs: 8 },
        hard:   { cols: 6, pairs: 12 },
      };

      // Elements
      const levelSel = document.getElementById('level');
      const board = document.getElementById('board');
      const movesEl = document.getElementById('moves');
      const timeEl = document.getElementById('time');
      const bestEl = document.getElementById('best');
      const restartBtn = document.getElementById('restart');

      const modal = document.getElementById('win-modal');
      const sumMoves = document.getElementById('sum-moves');
      const sumTime  = document.getElementById('sum-time');
      const sumBest  = document.getElementById('sum-best');
      const playAgainBtn = document.getElementById('play-again');
      const changeLevelBtn = document.getElementById('change-level');

      // State
      let state = {
        level: levelSel.value,
        deck: [],
        first: null,
        lock: false,
        moves: 0,
        matches: 0,
        timerId: null,
        startTime: null
      };

      // Utils
      const pad = n => n.toString().padStart(2,'0');
      function formatTime(s) {
        s = Math.max(0, Math.floor(s));
        const m = Math.floor(s/60);
        const r = s % 60;
        return `${pad(m)}:${pad(r)}`;
      }
      function shuffle(arr){
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
        return arr;
      }
      function getBest(level){
        try{
          const raw = localStorage.getItem(`memory-best-${level}`);
          return raw ? JSON.parse(raw) : null;
        }catch(e){ return null }
      }
      function setBest(level, data){
        try{ localStorage.setItem(`memory-best-${level}`, JSON.stringify(data)); }catch(e){}
      }
      function betterScore(a,b){
        // Lower moves is better; tie-breaker lower time
        if(!b) return true;
        if(a.moves < b.moves) return true;
        if(a.moves === b.moves && a.time < b.time) return true;
        return false;
      }

      // Game
      function buildDeck(levelKey){
        const {pairs} = LEVELS[levelKey];
        const pool = shuffle(EMOJIS.slice()).slice(0, pairs);
        const doubled = shuffle([...pool, ...pool]);
        return doubled.map((emoji, i)=>({ id:i+'-'+Math.random().toString(36).slice(2,7), emoji, matched:false }));
      }

      function renderBoard(){
        const { cols } = LEVELS[state.level];
        board.style.setProperty('--cols', cols);
        board.innerHTML = '';
        state.deck.forEach((card, index)=>{
          const wrapper = document.createElement('div');
          wrapper.className = 'card';
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.setAttribute('aria-label', 'Hidden card');
          btn.dataset.index = index;

          const front = document.createElement('div');
          front.className = 'face front';
          const back = document.createElement('div');
          back.className = 'face back';
          back.textContent = card.emoji;

          btn.appendChild(front); btn.appendChild(back);
          wrapper.appendChild(btn);
          board.appendChild(wrapper);
        });
      }

      function startTimer(){
        if(state.timerId) return;
        state.startTime = performance.now();
        state.timerId = setInterval(()=>{
          const elapsed = (performance.now() - state.startTime)/1000;
          timeEl.textContent = formatTime(elapsed);
        }, 250);
      }

      function stopTimer(){
        if(state.timerId){
          clearInterval(state.timerId);
          state.timerId = null;
        }
      }

      function reset(){
        stopTimer();
        state.deck = buildDeck(state.level);
        state.first = null;
        state.lock = false;
        state.moves = 0;
        state.matches = 0;
        state.startTime = null;
        movesEl.textContent = '0';
        timeEl.textContent = '00:00';
        updateBestBadge();
        renderBoard();
      }

      function updateBestBadge(){
        const best = getBest(state.level);
        bestEl.textContent = best ? `${best.moves} / ${formatTime(best.time)}` : '—';
      }

      function flip(btn){
        btn.classList.add('flipped');
        btn.setAttribute('aria-label', 'Revealed card');
      }
      function unflip(btn){
        btn.classList.remove('flipped');
        btn.setAttribute('aria-label', 'Hidden card');
      }

      function onCardClick(e){
        const btn = e.target.closest('button');
        if(!btn) return;
        const i = Number(btn.dataset.index);
        const card = state.deck[i];
        if(!card || state.lock) return;
        if(btn.classList.contains('flipped')) return;

        // start timer on first action
        if(!state.startTime) startTimer();

        flip(btn);
        if(!state.first){
          state.first = { i, btn, card };
          return;
        }

        state.moves++;
        movesEl.textContent = String(state.moves);

        const first = state.first;
        state.first = null;

        if(card.emoji === first.card.emoji){
          // Match
          card.matched = true;
          first.card.matched = true;
          btn.parentElement.classList.add('matched');
          first.btn.parentElement.classList.add('matched');
          btn.classList.add('disabled');
          first.btn.classList.add('disabled');
          state.matches++;
          if(state.matches === state.deck.length/2){
            gameWon();
          }
        }else{
          // Mismatch
          state.lock = true;
          setTimeout(()=>{
            unflip(btn); unflip(first.btn);
            state.lock = false;
          }, 700);
        }
      }

      function gameWon(){
        stopTimer();
        const elapsed = state.startTime ? Math.floor((performance.now() - state.startTime)/1000) : 0;
        const score = { moves: state.moves, time: elapsed };
        const best = getBest(state.level);
        if(betterScore(score, best)) setBest(state.level, score);

        // Update modal stats
        sumMoves.textContent = String(score.moves);
        sumTime.textContent = formatTime(score.time);
        const newBest = getBest(state.level);
        sumBest.textContent = newBest ? `${newBest.moves} / ${formatTime(newBest.time)}` : '—';
        updateBestBadge();

        modal.classList.add('show');
      }

      // Events
      board.addEventListener('click', onCardClick);
      restartBtn.addEventListener('click', ()=>reset());
      levelSel.addEventListener('change', ()=>{
        state.level = levelSel.value;
        reset();
      });
      playAgainBtn.addEventListener('click', ()=>{
        modal.classList.remove('show');
        reset();
      });
      changeLevelBtn.addEventListener('click', ()=>{
        modal.classList.remove('show');
        // Cycle levels for quick change
        const order = ['easy','medium','hard'];
        const idx = order.indexOf(state.level);
        const next = order[(idx+1)%order.length];
        levelSel.value = next;
        state.level = next;
        reset();
      });
      modal.addEventListener('click', (e)=>{
        if(e.target === modal) modal.classList.remove('show');
      });

      // Init
      reset();
    })();
  </script>
</body>
</html>